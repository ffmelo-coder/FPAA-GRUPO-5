# PathFinder V1.0 - Resolvendo o Labirinto 2D com Algoritmos de Busca

## Contexto

Este projeto implementa algoritmos de busca para encontrar o menor caminho entre dois pontos em um labirinto 2D, evitando obstáculos.

O robô parte de um ponto inicial **S** (start) e precisa chegar ao ponto final **E** (end), movendo-se apenas entre células livres, sem colidir com obstáculos.

## Objetivo

Implementar e comparar diferentes algoritmos de busca de caminhos:

- **Algoritmo A\***: Busca informada usando heurística para otimizar a exploração
- **Flood Fill (BFS)**: Busca em largura explorando todas as possibilidades uniformemente

## Como executar

### Requisitos

- Python 3.x instalado
- Bibliotecas necessárias (veja seção de instalação abaixo)

### Instalação de Dependências

Antes de executar o programa, instale as dependências necessárias:

```bash
pip install numpy matplotlib
```

Ou, se você tiver um arquivo `requirements.txt`:

```bash
pip install -r requirements.txt
```

### Execução

```bash
python main.py
```

### Fluxo do Programa

1. **Escolha do Algoritmo**: Selecione entre A\* ou Flood Fill
2. **Configuração do Labirinto**: Escolha entre entrada manual ou geração aleatória
3. **Movimentação Diagonal** (apenas para A\*): Defina se permite movimentos diagonais
4. **Visualização**: Escolha se deseja ver a animação do processo de busca

### Entrada Manual

O programa solicitará que você digite o labirinto linha por linha:

- **0**: Célula livre (onde o robô pode se mover)
- **1**: Obstáculo (onde o robô não pode passar)
- **S ou 2**: Ponto inicial (start)
- **E ou 3**: Ponto final (end)

Digite cada linha separada por espaços e pressione Enter. Quando terminar, pressione Enter em uma linha vazia.

### Exemplo de entrada:

```
S 0 1 0 0
0 0 1 0 1
1 0 1 0 0
1 0 0 E 1
```

### Geração Aleatória

Você pode optar por gerar um labirinto aleatório informando:

- Número de linhas (X)
- Número de colunas (Y)
- Densidade de obstáculos (0.0 a 0.8, padrão 0.3)

O programa garante que início e fim estarão em quadrantes opostos com distância mínima adequada.

### Saída

O programa retorna:

1. O menor caminho em formato de coordenadas: `[(0, 0), (1, 0), (1, 1), (2, 1), ...]`
2. O labirinto com o caminho destacado usando `*`
3. (Opcional) Animação visual mostrando o processo de exploração

## Estrutura do projeto

```
FPAA GRUPO/
├── main.py          # Programa principal com entrada de dados e seleção de algoritmos
├── pathfinder.py    # Implementação do algoritmo A*
├── floodfill.py     # Implementação do algoritmo Flood Fill (BFS)
├── testes.py        # Testes automatizados
```

## Algoritmos Implementados

### Algoritmo A\*

O algoritmo A\* combina:

- **g(n)**: Custo real do caminho do início até o nó atual
- **h(n)**: Heurística (estimativa) da distância do nó atual até o destino
- **f(n) = g(n) + h(n)**: Função de avaliação total

#### Heurística de Manhattan (4 direções)

```
h(n) = |x_atual - x_final| + |y_atual - y_final|
```

Esta heurística estima a distância entre dois pontos somando as diferenças absolutas de suas coordenadas.

#### Heurística Euclidiana (movimentação diagonal)

Quando a movimentação diagonal está habilitada, o algoritmo usa a distância euclidiana:

```
h(n) = √((x_atual - x_final)² + (y_atual - y_final)²)
```

Esta heurística fornece uma estimativa mais precisa quando movimentos diagonais são permitidos.

#### Custos de Movimento

- Movimentação horizontal/vertical: custo = 1
- Movimentação diagonal: custo = √2 ≈ 1.414

### Algoritmo Flood Fill (BFS)

O Flood Fill implementado utiliza Breadth-First Search (Busca em Largura):

- Explora o labirinto camada por camada, partindo do ponto inicial
- Garante encontrar o caminho mais curto em termos de número de passos
- Utiliza apenas movimentos ortogonais (4 direções: cima, baixo, esquerda, direita)
- Não usa heurística, explorando uniformemente todas as direções
- Ideal para comparação com algoritmos informados como A\*

**Por que Flood Fill?** Este algoritmo foi implementado como curiosidade e para fins educacionais, permitindo visualizar e comparar diferentes abordagens de busca em labirintos. Enquanto o A\* é otimizado com heurística, o Flood Fill demonstra uma abordagem mais simples e sistemática de exploração.

## Visualização Animada

O programa oferece visualização animada opcional que mostra:

- **Células exploradas** (azul claro): mostra o processo de busca passo a passo
- **Caminho final** (amarelo): destaca o caminho encontrado
- **Início** (verde) e **Fim** (vermelho): pontos de partida e chegada
- **Sem solução**: quando não há caminho possível, a animação indica claramente

### ⚠️ Nota de Performance

**Para labirintos muito grandes (acima de 50x50), as animações podem ser significativamente lentas.** Isso ocorre porque cada frame precisa atualizar e renderizar toda a matriz. Para labirintos grandes, recomenda-se:

- Desabilitar a visualização animada
- Usar labirintos menores para demonstrações visuais
- Considerar que o algoritmo em si é rápido; a lentidão está apenas na renderização gráfica

## Uso de Inteligência Artificial

**Transparência no Desenvolvimento**: Parte do código de visualização animada foi desenvolvida com auxílio de IA (GitHub Copilot). Especificamente:

- Implementação das animações com `matplotlib`
- Estruturação dos frames de visualização
- Otimizações de renderização

O código foi revisado, testado e adaptado para atender aos requisitos específicos do projeto. Os algoritmos principais (A\* e Flood Fill) foram implementados manualmente pela equipe.

## Primeira Entrega

Esta primeira versão inclui:

- ✅ Leitura do labirinto via entrada do usuário
- ✅ Geração aleatória de labirintos
- ✅ Identificação automática dos pontos S e E
- ✅ Implementação da heurística de Manhattan
- ✅ Implementação da heurística Euclidiana para movimento diagonal
- ✅ Algoritmo A\* básico funcional
- ✅ Algoritmo Flood Fill (BFS) implementado
- ✅ Movimentação nas 4 direções (cima, baixo, esquerda, direita)
- ✅ Movimentação diagonal opcional (8 direções) para A\*
- ✅ Validação se S e E existem no labirinto
- ✅ Validação de unicidade de S e E
- ✅ Validação de formato do labirinto (matriz retangular)
- ✅ Tratamento de erros de entrada inválida
- ✅ Exibição do caminho encontrado
- ✅ Visualização do labirinto com caminho destacado
- ✅ Sistema de custos diferenciados (1 para reto, √2 para diagonal)
- ✅ Visualização animada do processo de busca
- ✅ Comparação entre diferentes algoritmos de busca
- ✅ Uso de NumPy para geração aleatória otimizada

## Autores

Filipe Faria Melo

Augusto Fuscaldi Cerezo
